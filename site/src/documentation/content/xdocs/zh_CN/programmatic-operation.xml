<?xml version="1.0"?>

<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" 
          "http://forrest.apache.org/dtd/document-v20.dtd">

<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<document> 

  <header> 
    <title>Programmatic Operation</title> 
  </header> 

  <body> 
    <section>
      <title>Programmatic Operation</title>
      <p></p>
      <p>A certain subset of ManifoldCF users want to think of ManifoldCF as an engine that they can poke from whatever other system they are developing.  While
        ManifoldCF is not precisely a document indexing engine per se, it can certainly be controlled programmatically.  Right now, there are three principle ways of
        achieving this control.</p>
      <p></p>
      <section>
        <title>Control by Servlet API</title>
        <p></p>
        <p>ManifoldCF provides a servlet-based JSON API that gives you the complete ability to define connections and jobs, and control job execution.  You can read
          about JSON <a href="http://www.json.org">here</a>.  The API is designed to be RESTful in character.  Thus, it makes full use of the HTTP verbs
          GET, PUT, POST, and DELETE, and represents objects as URLs.</p>
        <section>
          <title>URL format</title>
          <p></p>
          <p>The basic format of the JSON servlet resource URLs is as follows:</p>
          <p></p>
          <p>http[s]://<em>&lt;server_and_port&gt;</em>/mcf-api-service/json/<em>&lt;resource&gt;</em></p>
          <p></p>
          <p>The servlet ignores request data, except when the PUT or POST verb is used.  In that case, the request data is presumed to be a JSON object.  The servlet
            responds either with an error response code (either 400 or 500) with an appropriate explanatory message, or with a 200 (OK), 201 (CREATED), 
            401 (UNAUTHORIZED), or 404 (NOT FOUND) response code along with a response JSON object.</p>
          <p></p>
        </section>
        <section>
          <title>JSON equivalents for ManifoldCF</title>
          <p></p>
          <p>ManifoldCF treats certain JSON forms as equivalent, for the purposes of readability.  For example, the array form <strong>"foo" : [ { ... } ]</strong> is
            treated equivalently to <strong>"foo" : { }</strong>, whenever there is only one array element.  This gives a coder some flexibility as to how s/he encodes
            JSON in requests.  Please also be aware that similar compressions will occur in the JSON responses from the API servlet, and your code must be able to deal
            with this possibility.  The following table describes some of the equivalences:</p>
          <p></p>
          <p></p>
          <p></p>
          <table>
            <tr><th>Form</th><th>Equivalent</th></tr>
            <tr><td>[ { ... } ]</td><td>{ ... }</td></tr>
            <tr><td>"foo" : { "_value_" : "bar" }</td><td>"foo" : "bar"</td></tr>
            <tr><td>"_children_" : [ "foo":{ ... }, "foo":{ ... } ]</td><td>"foo" : [ { ... }, { ... } ]</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Resources and commands</title>
          <p></p>
          <p>The actual available resources and commands are as follows:</p>
          <p></p>
          <p></p>
          <p></p>
          <table>
            <tr><th>Resource</th><th>Verb</th><th>What it does</th><th>Input format/query args</th><th>Output format</th></tr>
            <tr><td>LOGIN</td><td>POST</td><td>Log in the specified user</td><td>{"userID":<em>&lt;user_name&gt;</em>, "password":<em>&lt;password&gt;</em>}</td><td>{}</td></tr>
            <tr><td>authorizationdomains</td><td>GET</td><td>List all registered authorization domains</td><td>N/A</td><td>{"authorizationdomain":[<em>&lt;list_of_authorization_domain_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>outputconnectors</td><td>GET</td><td>List all registered output connectors</td><td>N/A</td><td>{"outputconnector":[<em>&lt;list_of_output_connector_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>transformationconnectors</td><td>GET</td><td>List all registered transformation connectors</td><td>N/A</td><td>{"transformationconnector":[<em>&lt;list_of_transformation_connector_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>mappingconnectors</td><td>GET</td><td>List all registered mapping connectors</td><td>N/A</td><td>{"mappingconnector":[<em>&lt;list_of_mapping_connector_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnectors</td><td>GET</td><td>List all registered authority connectors</td><td>N/A</td><td>{"authorityconnector":[<em>&lt;list_of_authority_connector_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnectors</td><td>GET</td><td>List all registered repository connectors</td><td>N/A</td><td>{"repositoryconnector":[<em>&lt;list_of_repository_connector_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>notificationconnectors</td><td>GET</td><td>List all registered notification connectors</td><td>N/A</td><td>{"notificationconnector":[<em>&lt;list_of_notification_connector_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authoritygroups</td><td>GET</td><td>List all authority groups</td><td>N/A</td><td>{"authoritygroup":[<em>&lt;list_of_authority_group_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authoritygroups/<em>&lt;encoded_group_name&gt;</em></td><td>GET</td><td>Get a specific authority group</td><td>N/A</td><td>{"authoritygroup":<em>&lt;authority_group_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authoritygroups/<em>&lt;encoded_group_name&gt;</em></td><td>PUT</td><td>Save or create an authority group</td><td>{"authoritygroup":<em>&lt;authority_group_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authoritygroups/<em>&lt;encoded_group_name&gt;</em></td><td>DELETE</td><td>Delete an authority group</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>outputconnections</td><td>GET</td><td>List all output connections</td><td>N/A</td><td>{"outputconnection":[<em>&lt;list_of_output_connection_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>outputconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a specific output connection</td><td>N/A</td><td>{"outputconnection":<em>&lt;output_connection_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>outputconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Save or create an output connection</td><td>{"outputconnection":<em>&lt;output_connection_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>outputconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>DELETE</td><td>Delete an output connection</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>status/outputconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Check the status of an output connection</td><td>N/A</td><td>{"check_result":<em>&lt;message&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>info/outputconnections/<em>&lt;encoded_connection_name&gt;</em>/<em>&lt;connector_specific_resource&gt;</em></td><td>GET</td><td>Retrieve arbitrary connector-specific resource</td><td>N/A</td><td><em>&lt;response_data&gt;</em> <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} <strong>OR</strong> {"service_interruption":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>transformationconnections</td><td>GET</td><td>List all transformation connections</td><td>N/A</td><td>{"transformationconnection":[<em>&lt;list_of_transformation_connection_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>transformationconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a specific transformation connection</td><td>N/A</td><td>{"transformationconnection":<em>&lt;transformation_connection_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>transformationconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Save or create a transformation connection</td><td>{"outputconnection":<em>&lt;transformation_connection_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>transformationconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>DELETE</td><td>Delete a transformation connection</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>status/transformationconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Check the status of a transformation connection</td><td>N/A</td><td>{"check_result":<em>&lt;message&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>info/transformationconnections/<em>&lt;encoded_connection_name&gt;</em>/<em>&lt;connector_specific_resource&gt;</em></td><td>GET</td><td>Retrieve arbitrary connector-specific resource</td><td>N/A</td><td><em>&lt;response_data&gt;</em> <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} <strong>OR</strong> {"service_interruption":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>clearversions/<em>&lt;encoded_output_connection_name&gt;</em></td><td>PUT</td><td>Forget previous indexed document versions</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>clearrecords/<em>&lt;encoded_output_connection_name&gt;</em></td><td>PUT</td><td>Remove all previous indexing records</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>mappingconnections</td><td>GET</td><td>List all mapping connections</td><td>N/A</td><td>{"mappingconnection":[<em>&lt;list_of_mapping_connection_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>mappingconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a specific mapping connection</td><td>N/A</td><td>{"mappingconnection":<em>&lt;mapping_connection_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>mappingconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Save or create a mapping connection</td><td>{"mappingconnection":<em>&lt;mapping_connection_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>mappingconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>DELETE</td><td>Delete a mapping connection</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>status/mappingconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Check the status of a mapping connection</td><td>N/A</td><td>{"check_result":<em>&lt;message&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnections</td><td>GET</td><td>List all authority connections</td><td>N/A</td><td>{"authorityconnection":[<em>&lt;list_of_authority_connection_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a specific authority connection</td><td>N/A</td><td>{"authorityconnection":<em>&lt;authority_connection_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Save or create an authority connection</td><td>{"authorityconnection":<em>&lt;authority_connection_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>DELETE</td><td>Delete an authority connection</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>status/authorityconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Check the status of an authority connection</td><td>N/A</td><td>{"check_result":<em>&lt;message&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnections</td><td>GET</td><td>List all repository connections</td><td>N/A</td><td>{"repositoryconnection":[<em>&lt;list_of_repository_connection_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a specific repository connection</td><td>N/A</td><td>{"repositoryconnection":<em>&lt;repository_connection_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Save or create a repository connection</td><td>{"repositoryconnection":<em>&lt;repository_connection_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>DELETE</td><td>Delete a repository connection</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>status/repositoryconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Check the status of a repository connection</td><td>N/A</td><td>{"check_result":<em>&lt;message&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>info/repositoryconnections/<em>&lt;encoded_connection_name&gt;</em>/<em>&lt;connector_specific_resource&gt;</em></td><td>GET</td><td>Retrieve arbitrary connector-specific resource</td><td>N/A</td><td><em>&lt;response_data&gt;</em> <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} <strong>OR</strong> {"service_interruption":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>notificationconnections</td><td>GET</td><td>List all notification connections</td><td>N/A</td><td>{"notificationconnection":[<em>&lt;list_of_notification_connection_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>notificationconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a specific notification connection</td><td>N/A</td><td>{"notificationconnection":<em>&lt;notification_connection_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>notificationconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Save or create a notification connection</td><td>{"notificationconnection":<em>&lt;notification_connection_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>notificationconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>DELETE</td><td>Delete a notification connection</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>status/notificationconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Check the status of a notification connection</td><td>N/A</td><td>{"check_result":<em>&lt;message&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>info/notificationconnections/<em>&lt;encoded_connection_name&gt;</em>/<em>&lt;connector_specific_resource&gt;</em></td><td>GET</td><td>Retrieve arbitrary connector-specific resource</td><td>N/A</td><td><em>&lt;response_data&gt;</em> <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} <strong>OR</strong> {"service_interruption":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>clearhistory/<em>&lt;encoded_repository_connection_name&gt;</em></td><td>PUT</td><td>Clear history linked with repository connection</td><td>N/A</td><td><em>&lt;response_data&gt;</em> <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} <strong>OR</strong> {"service_interruption":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs</td><td>GET</td><td>List all job definitions</td><td>N/A</td><td>{"job":[<em>&lt;list_of_job_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs</td><td>POST</td><td>Create a job</td><td>{"job":<em>&lt;job_object&gt;</em>}</td><td>{"job_id":<em>&lt;job_identifier&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs/<em>&lt;job_id&gt;</em></td><td>GET</td><td>Get a specific job definition</td><td>N/A</td><td>{"job":<em>&lt;job_object_&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Save a job definition</td><td>{"job":<em>&lt;job_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs/<em>&lt;job_id&gt;</em></td><td>DELETE</td><td>Delete a job definition</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobstatuses</td><td>GET</td><td>List all jobs and their status</td><td>maxcount=&lt;maximum_documents_to_count&gt;</td><td>{"jobstatus":[<em>&lt;list_of_job_status_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobstatuses/<em>&lt;job_id&gt;</em></td><td>GET</td><td>Get a specific job's status</td><td>maxcount=&lt;maximum_documents_to_count&gt;</td><td>{"jobstatus":<em>&lt;job_status_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} </td></tr>
            <tr><td>jobstatusesnocounts<em>&lt;job_id&gt;</em></td><td>GET</td><td>List all jobs and their status, returning '0' for all counts</td><td>N/A</td><td>{"jobstatus":[<em>&lt;list_of_job_status_objects&gt;</em>]} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} </td></tr>
            <tr><td>jobstatusesnocounts/<em>&lt;job_id&gt;</em></td><td>GET</td><td>Get a specific job's status, returning '0' for all counts</td><td>N/A</td><td>{"jobstatus":<em>&lt;job_status_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} </td></tr>
            <tr><td>start/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Start a specified job manually</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>startminimal/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Start a specified job manually, minimal run requested</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>abort/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Abort a specified job</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>restart/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Stop and start a specified job</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>restartminimal/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Stop and start a specified job, minimal run requested</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>pause/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Pause a specified job</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>resume/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Resume a specified job</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>reseed/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Reset incremental seeding for a specified job</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>

            <tr><td>repositoryconnectionhistory/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a history report</td><td><em>&lt;history_query_parameters&gt;</em></td><td>{"row":[{"column":[{"name":<em>&lt;col_name&gt;</em>,"value":<em>&lt;col_value&gt;</em>}, ...]}, ...]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnectionquery/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a queue report</td><td><em>&lt;queue_query_parameters&gt;</em></td><td>{"row":[{"column":[{"name":<em>&lt;col_name&gt;</em>,"value":<em>&lt;col_value&gt;</em>}, ...]}, ...]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnectionactivities/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a list of legal activities for a connection</td><td>N/A</td><td>{"activity":[<em>&lt;activity_name&gt;</em>, ...]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnectionjobs/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a list of jobs for a connection</td><td>N/A</td><td>{"job":[<em>&lt;list_of_job_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>

          </table>
          <p></p>
        </section>
        <section>
          <title>History query parameters</title>
          <p></p>
          <p>The history query parameters and their meanings are as follows:</p>
          <table>
            <tr><th>Parameter</th><th>Report type</th><th>Multivalued?</th><th>Meaning</th></tr>
            <tr><td>report</td><td>All</td><td>No</td><td>The kind of history report desired; legal values are "simple", "maxactivity", "maxbandwidth", and "result"; defaults to "simple"</td></tr>
            <tr><td>starttime</td><td>All</td><td>No</td><td>Starting time in ms since epoch; defaults to "0"</td></tr>
            <tr><td>endtime</td><td>All</td><td>No</td><td>Ending time in ms since epoch; defaults to now</td></tr>
            <tr><td>activity</td><td>All</td><td>Yes</td><td>Which activities you want to see</td></tr>
            <tr><td>entitymatch</td><td>All</td><td>No</td><td>Regular expression matching entity identifier; defaults to ""</td></tr>
            <tr><td>entitymatch_insensitive</td><td>All</td><td>No</td><td>Case insensitive version of entitymatch</td></tr>
            <tr><td>resultcodematch</td><td>All</td><td>No</td><td>Regular expression match result code; defaults to ""</td></tr>
            <tr><td>resultcodematch_insensitive</td><td>All</td><td>No</td><td>Case insensitive version of resultcodematch</td></tr>
            <tr><td>sortcolumn</td><td>All</td><td>Yes</td><td>Result column to sort the result by</td></tr>
            <tr><td>sortcolumn_direction</td><td>All</td><td>Yes</td><td>Direction to sort the corresponding column ("ascending" or "descending")</td></tr>
            <tr><td>startrow</td><td>All</td><td>No</td><td>Starting row in resultset to return; defaults to 0</td></tr>
            <tr><td>rowcount</td><td>All</td><td>No</td><td>Maximum number of rows to return; defaults to 20</td></tr>
            <tr><td>idbucket</td><td>maxactivity, maxbandwidth, result</td><td>No</td><td>Regular expression selecting which part of the entity identifier to use as an aggregation key; defaults to "()"</td></tr>
            <tr><td>idbucket_insensitive</td><td>maxactivity, maxbandwidth, result</td><td>No</td><td>Case insensitive version of idbucket</td></tr>
            <tr><td>resultcodebucket</td><td>result</td><td>No</td><td>Regular expression selecting which part of the result code to use as an aggregation key; defaults to "(.*)"</td></tr>
            <tr><td>resultcodebucket_insensitive</td><td>result</td><td>No</td><td>Case insensitive version of resultcodebucket</td></tr>
            <tr><td>interval</td><td>maxactivity, maxbandwidth</td><td>No</td><td>Size of window in milliseconds for assessing rate; defaults to 300000</td></tr>
          </table>
          <p></p>
          <p>Each report type has different return columns, as listed below:</p>
          <p></p>
          <table>
            <tr><th>Report type</th><th>Return columns</th></tr>
            <tr><td>simple</td><td>starttime, resultcode, resultdesc, identifier, activity, bytes, elapsedtime</td></tr>
            <tr><td>maxactivity</td><td>starttime, endtime, activitycount, idbucket</td></tr>
            <tr><td>maxbandwidth</td><td>starttime, endtime, bytecount, idbucket</td></tr>
            <tr><td>result</td><td>idbucket, resultcodebucket, eventcount</td></tr>
          </table>
        </section>
        <section>
          <title>Queue query parameters</title>
          <p></p>
          <p>The queue query parameters and their meanings are as follows:</p>
          <table>
            <tr><th>Parameter</th><th>Report type</th><th>Multivalued?</th><th>Meaning</th></tr>
            <tr><td>report</td><td>All</td><td>No</td><td>The kind of queue report desired; legal values are "document" or "status"; defaults to "document"</td></tr>
            <tr><td>now</td><td>All</td><td>No</td><td>The time in milliseconds since epoch to perform the queue assessment relative to; defaults to current time</td></tr>
            <tr><td>idmatch</td><td>All</td><td>No</td><td>Regular expression matching document identifier; defaults to ""</td></tr>
            <tr><td>idmatch_insensitive</td><td>All</td><td>No</td><td>Case insensitive version of idmatch</td></tr>
            <tr><td>statematch</td><td>All</td><td>Yes</td><td>State to match; valid values are "neverprocessed", "previouslyprocessed", "outofscope"</td></tr>
            <tr><td>statusmatch</td><td>All</td><td>Yes</td><td>Status to match; valid values are "inactive", "processing", "expiring", "deleting", "readyforprocessing", "readyforexpiration", "waitingforprocessing", "waitingforexpiration", "waitingforever", and "hopcountexceeded"</td></tr>
            <tr><td>sortcolumn</td><td>All</td><td>Yes</td><td>Result column to sort the result by</td></tr>
            <tr><td>sortcolumn_direction</td><td>All</td><td>Yes</td><td>Direction to sort the corresponding column ("ascending" or "descending")</td></tr>
            <tr><td>startrow</td><td>All</td><td>No</td><td>Starting row in resultset to return; defaults to 0</td></tr>
            <tr><td>rowcount</td><td>All</td><td>No</td><td>Maximum number of rows to return; defaults to 20</td></tr>
            <tr><td>idbucket</td><td>status</td><td>No</td><td>Regular expression selecting which part of the document identifier to use as an aggregation key; defaults to "()"</td></tr>
            <tr><td>idbucket_insensitive</td><td>status</td><td>No</td><td>Case insensitive version of idbucket</td></tr>
          </table>
          <p></p>
          <p>Each report type has different return columns, as listed below:</p>
          <p></p>
          <table>
            <tr><th>Report type</th><th>Return columns</th></tr>
            <tr><td>document</td><td>identifier, job, state, status, scheduled, action, retrycount, retrylimit</td></tr>
            <tr><td>status</td><td>idbucket, inactive, processing, expiring, deleting, processready, expireready, processwaiting, expirewaiting, waitingforever, hopcountexceeded</td></tr>
          </table>
        </section>
        <section>
          <title>Authorization domain objects</title>
          <p></p>
          <p>The JSON fields an authorization domain object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the authorization domain</td></tr>
            <tr><td>"domain_name"</td><td>The internal name of the authorization domain, i.e. what is sent to the Authority Service</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Output connector objects</title>
          <p></p>
          <p>The JSON fields an output connector object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the connector</td></tr>
            <tr><td>"class_name"</td><td>The class name of the class implementing the connector</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Transformation connector objects</title>
          <p></p>
          <p>The JSON fields a transformation connector object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the connector</td></tr>
            <tr><td>"class_name"</td><td>The class name of the class implementing the connector</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Mapping connector objects</title>
          <p></p>
          <p>The JSON fields a mapping connector object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the connector</td></tr>
            <tr><td>"class_name"</td><td>The class name of the class implementing the connector</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Authority connector objects</title>
          <p></p>
          <p>The JSON fields an authority connector object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the connector</td></tr>
            <tr><td>"class_name"</td><td>The class name of the class implementing the connector</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Repository connector objects</title>
          <p></p>
          <p>The JSON fields a repository connector object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the connector</td></tr>
            <tr><td>"class_name"</td><td>The class name of the class implementing the connector</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Notification connector objects</title>
          <p></p>
          <p>The JSON fields a repository connector object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the connector</td></tr>
            <tr><td>"class_name"</td><td>The class name of the class implementing the connector</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Authority group objects</title>
          <p></p>
          <p>Authority group names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields an authority group object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the group</td></tr>
            <tr><td>"description"</td><td>The description of the group</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Output connection objects</title>
          <p></p>
          <p>Output connection names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields an output connection object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the connection</td></tr>
            <tr><td>"description"</td><td>The description of the connection</td></tr>
            <tr><td>"class_name"</td><td>The java class name of the class implementing the connection</td></tr>
            <tr><td>"max_connections"</td><td>The total number of outstanding connections allowed to exist at a time</td></tr>
            <tr><td>"configuration"</td><td>The configuration object for the connection, which is specific to the connection class</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Transformation connection objects</title>
          <p></p>
          <p>Transformation connection names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields an output connection object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the connection</td></tr>
            <tr><td>"description"</td><td>The description of the connection</td></tr>
            <tr><td>"class_name"</td><td>The java class name of the class implementing the connection</td></tr>
            <tr><td>"max_connections"</td><td>The total number of outstanding connections allowed to exist at a time</td></tr>
            <tr><td>"configuration"</td><td>The configuration object for the connection, which is specific to the connection class</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Mapping connection objects</title>
          <p></p>
          <p>Mapping connection names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields for a mapping connection object are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the connection</td></tr>
            <tr><td>"description"</td><td>The description of the connection</td></tr>
            <tr><td>"class_name"</td><td>The java class name of the class implementing the connection</td></tr>
            <tr><td>"max_connections"</td><td>The total number of outstanding connections allowed to exist at a time</td></tr>
            <tr><td>"configuration"</td><td>The configuration object for the connection, which is specific to the connection class</td></tr>
            <tr><td>"prerequisite"</td><td>The mapping connection prerequisite, if any</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Authority connection objects</title>
          <p></p>
          <p>Authority connection names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields for an authority connection object are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the connection</td></tr>
            <tr><td>"description"</td><td>The description of the connection</td></tr>
            <tr><td>"class_name"</td><td>The java class name of the class implementing the connection</td></tr>
            <tr><td>"max_connections"</td><td>The total number of outstanding connections allowed to exist at a time</td></tr>
            <tr><td>"configuration"</td><td>The configuration object for the connection, which is specific to the connection class</td></tr>
            <tr><td>"prerequisite"</td><td>The mapping connection prerequisite, if any</td></tr>
            <tr><td>"authdomain"</td><td>The authorization domain for the authority connection, if any</td></tr>
            <tr><td>"authgroup"</td><td>The required authority group for the authority connection</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Repository connection objects</title>
          <p></p>
          <p>Repository connection names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields for a repository connection object are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the connection</td></tr>
            <tr><td>"description"</td><td>The description of the connection</td></tr>
            <tr><td>"class_name"</td><td>The java class name of the class implementing the connection</td></tr>
            <tr><td>"max_connections"</td><td>The total number of outstanding connections allowed to exist at a time</td></tr>
            <tr><td>"configuration"</td><td>The configuration object for the connection, which is specific to the connection class</td></tr>
            <tr><td>"acl_authority"</td><td>The (optional) name of the authority group that will enforce security for this connection</td></tr>
            <tr><td>"throttle"</td><td>An array of throttle objects, which control how quickly documents can be requested from this connection</td></tr>
          </table>
          <p></p>
          <p>Each throttle object has the following fields:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"match"</td><td>The regular expression which is used to match a document's bins to determine if the throttle should be applied</td></tr>
            <tr><td>"match_description"</td><td>Optional text describing the meaning of the throttle</td></tr>
            <tr><td>"rate"</td><td>The maximum fetch rate to use if the throttle applies, in fetches per minute</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Notification connection objects</title>
          <p></p>
          <p>Notification connection names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields for a notification connection object are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the connection</td></tr>
            <tr><td>"description"</td><td>The description of the connection</td></tr>
            <tr><td>"class_name"</td><td>The java class name of the class implementing the connection</td></tr>
            <tr><td>"max_connections"</td><td>The total number of outstanding connections allowed to exist at a time</td></tr>
            <tr><td>"configuration"</td><td>The configuration object for the connection, which is specific to the connection class</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Job objects</title>
          <p></p>
          <p>The JSON fields for a job are is as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"id"</td><td>The job's identifier, if present.  If not present, ManifoldCF will create one (and will also create the job when saved).</td></tr>
            <tr><td>"description"</td><td>Text describing the job</td></tr>
            <tr><td>"repository_connection"</td><td>The name of the repository connection to use with the job</td></tr>
            <tr><td>"document_specification"</td><td>The document specification object for the job, whose format is repository-connection specific</td></tr>
            <tr><td>"start_mode"</td><td>The start mode for the job, which can be one of "schedule window start", "schedule window anytime", or "manual"</td></tr>
            <tr><td>"run_mode"</td><td>The run mode for the job, which can be either "continuous" or "scan once"</td></tr>
            <tr><td>"hopcount_mode"</td><td>The hopcount mode for the job, which can be either "accurate", "no delete", "never delete"</td></tr>
            <tr><td>"priority"</td><td>The job's priority, typically "5"</td></tr>
            <tr><td>"recrawl_interval"</td><td>The default time between recrawl of documents (if the job is "continuous"), in milliseconds, or "infinite" for infinity</td></tr>
            <tr><td>"max_recrawl_interval"</td><td>The maximum time between recrawl of documents (if the job is "continuous"), in milliseconds, or "infinite" for infinity</td></tr>
            <tr><td>"expiration_interval"</td><td>The time until a document expires (if the job is "continuous"), in milliseconds, or "infinite" for infinity</td></tr>
            <tr><td>"reseed_interval"</td><td>The time between reseeding operations (if the job is "continuous"), in milliseconds, or "infinite" for infinity</td></tr>
            <tr><td>"hopcount"</td><td>An array of hopcount objects, describing the link types and associated maximum hops permitted for the job</td></tr>
            <tr><td>"schedule"</td><td>An array of schedule objects, describing when the job should be started and run</td></tr>
            <tr><td>"pipelinestage"</td><td>An array of pipelinestage objects, describing what the transformation pipeline is</td></tr>
            <tr><td>"notificationstage"</td><td>An array of notificationstage objects, describing what the notifications are</td></tr>
          </table>
          <p></p>
          <p>Each pipelinestage object has the following fields:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"stage_id"</td><td>The unique identifier for the pipeline stage</td></tr>
            <tr><td>"stage_prerequisite"</td><td>The unique identifier for the preceding pipeline stage; may be missing if none</td></tr>
            <tr><td>"stage_isoutput"</td><td>"true" if the stage is an output connection</td></tr>
            <tr><td>"stage_connectionname"</td><td>The connection name for the pipeline stage</td></tr>
            <tr><td>"stage_description"</td><td>A description of the pipeline stage</td></tr>
            <tr><td>"stage_specification"</td><td>The specification string for the pipeline stage</td></tr>
          </table>
          <p></p>
          <p>Each notificationstage object has the following fields:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"stage_id"</td><td>The unique identifier for the notification stage</td></tr>
            <tr><td>"stage_connectionname"</td><td>The connection name for the notification stage</td></tr>
            <tr><td>"stage_description"</td><td>A description of the notification stage</td></tr>
            <tr><td>"stage_specification"</td><td>The specification string for the notification stage</td></tr>
          </table>
          <p></p>
          <p>Each hopcount object has the following fields:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"link_type"</td><td>The connection-type-dependent type of a link for which a hop count restriction is specified</td></tr>
            <tr><td>"count"</td><td>The maximum number of hops allowed for the associated link type, starting at a seed</td></tr>
          </table>
          <p></p>
          <p>Each schedule object has the following fields:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"timezone"</td><td>The optional time zone for the schedule object; if not present the default server time zone is used</td></tr>
            <tr><td>"duration"</td><td>The optional length of the described time window, in milliseconds; if not present, duration is considered infinite</td></tr>
            <tr><td>"dayofweek"</td><td>The optional day-of-the-week enumeration object</td></tr>
            <tr><td>"monthofyear"</td><td>The optional month-of-the-year enumeration object</td></tr>
            <tr><td>"dayofmonth"</td><td>The optional day-of-the-month enumeration object</td></tr>
            <tr><td>"year"</td><td>The optional year enumeration object</td></tr>
            <tr><td>"hourofday"</td><td>The optional hour-of-the-day enumeration object</td></tr>
            <tr><td>"minutesofhour"</td><td>The optional minutes-of-the-hour enumeration object</td></tr>
            <tr><td>"requestminimum"</td><td>Optional flag indicating whether the job run will be minimal or not ("true" means minimal)</td></tr>
          </table>
          <p></p>
          <p>Each enumeration object describes an array of integers using the form:</p>
          <p></p>
          <p>{"value":[<em>&lt;integer_list&gt;</em>]}</p>
          <p></p>
          <p>Each integer is a zero-based index describing which entity is being specified.  For example, for "dayofweek", 0 corresponds to Sunday, etc., and thus "dayofweek":{"value":[0,6]} would describe Saturdays and Sundays.</p>
          <p></p>
        </section>
        <section>
          <title>Job status objects</title>
          <p></p>
          <p>The JSON fields of a job status object are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"job_id"</td><td>The job identifier</td></tr>
            <tr><td>"status"</td><td>The job status, having the possible values: "not yet run", "running", "paused", "done", "waiting", "stopping", "resuming", "starting up", "cleaning up", "error", "aborting", "restarting", "running no connector", and "terminating"</td></tr>
            <tr><td>"error_text"</td><td>The error text, if the status is "error"</td></tr>
            <tr><td>"start_time"</td><td>The job start time, in milliseconds since Jan 1, 1970</td></tr>
            <tr><td>"end_time"</td><td>The job end time, in milliseconds since Jan 1, 1970</td></tr>
            <tr><td>"documents_in_queue"</td><td>The total number of documents in the queue for the job</td></tr>
            <tr><td>"documents_outstanding"</td><td>The number of documents for the job that are currently considered 'active'</td></tr>
            <tr><td>"documents_processed"</td><td>The number of documents that in the queue for the job that have been processed at least once</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Connection-type-specific objects</title>
          <p></p>
          <p>As you may note when trying to use the above JSON API methods, you cannot get very far in defining connections or jobs without knowing the JSON format of a connection's configuration information, or a job's connection-specific document specification and output specification information.  The form of these objects is controlled by the Java implementation of the underlying connector, and is translated directly into JSON, so if you write your own connector you should be able to figure out what it will be in the API.  For connectors already part of ManifoldCF, it remains an ongoing task to document these connector-specific objects.  This task is not yet underway.</p>
          <p></p>
          <p>Luckily, it is pretty easy to learn a lot about the objects in question by simply creating connections and jobs in the ManifoldCF crawler UI, and then inspecting the resulting JSON objects through the API.  In this way, it should be possible to do a decent job of coding most API-based integrations.  The one place where difficulties will certainly occur will be if you try to completely replace the ManifoldCF crawler UI with one of your own.  This is because most connectors have methods that communicate with their respective back-ends in order to allow the user to select appropriate values.  For example, the path drill-down that is presented by the LiveLink connector requires that the connector interrogate the appropriate LiveLink repository in order to populate its path selection pull-downs.  There is, at this time, only one sanctioned way to accomplish the same job using the API, which is to use the appropriate "<em>connection_type</em>/execute/<em>type-specific_command</em>" command to perform the necessary functions.  Some set of useful functions has been coded for every appropriate connector, but the exact commands for every connector, and their JSON syntax, remains undocumented for now.</p>
          <p></p>
        </section>
        <section>
          <title>File system connector</title>
          <p></p>
          <p>The file system connector has no configuration information, and no connector-specific commands.  However, it does have document specification information.  The information looks something like this:</p>
          <p></p>
          <p>{"startpoint":[{"_attribute_path":"c:\path_to_files","include":[{"_attribute_type":"file","_attribute_match":"*.txt"},{"_attribute_type":"file","_attribute_match":"*.doc"\,"_attribute_type":"directory","_attribute_match":"*"],"exclude":["*.mov"]]}</p>
          <p></p>
          <p>As you can see, multiple starting paths are possible, and the inclusion and exclusion rules also can be one or multiple.</p>
          <p></p>
          <p></p>
        </section>
      </section>
      <section>
        <title>Control via Commands</title>
        <p></p>
        <p>For script writers, there currently exist a number of ManifoldCF execution commands.  These commands are primarily rich in the area of definition of connections and jobs, controlling jobs, and running reports.  The following table lists the current suite.</p>
        <p></p>
        <table>
          <tr><th>Command</th><th>What it does</th></tr>
          <tr><td>org.apache.manifoldcf.agents.DefineOutputConnection</td><td>Create a new output connection</td></tr>
          <tr><td>org.apache.manifoldcf.agents.DeleteOutputConnection</td><td>Delete an existing output connection</td></tr>
          <tr><td>org.apache.manifoldcf.agents.DefineTransformationConnection</td><td>Create a new transformation connection</td></tr>
          <tr><td>org.apache.manifoldcf.agents.DeleteTransformationConnection</td><td>Delete an existing transformation connection</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.ChangeAuthSpec</td><td>Modify an authority's configuration information</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.CheckAll</td><td>Check all authorities to be sure they are functioning</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.DefineAuthorityConnection</td><td>Create a new authority connection</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.DeleteAuthorityConnection</td><td>Delete an existing authority connection</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.DefineMappingConnection</td><td>Create a new mapping connection</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.DeleteMappingConnection</td><td>Delete an existing mapping connection</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.AbortJob</td><td>Abort a running job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.AddScheduledTime</td><td>Add a schedule record to a job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ChangeJobDocSpec</td><td>Modify a job's specification information</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.DefineJob</td><td>Create a new job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.DefineRepositoryConnection</td><td>Create a new repository connection</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.DeleteJob</td><td>Delete an existing job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.DeleteRepositoryConnection</td><td>Delete an existing repository connection</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ExportConfiguration</td><td>Write the complete list of all connection definitions and job specifications to a file</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.FindJob</td><td>Locate a job identifier given a job's name</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.GetJobSchedule</td><td>Find a job's schedule given a job's identifier</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ImportConfiguration</td><td>Import configuration as written by a previous ExportConfiguration command</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ListJobStatuses</td><td>List the status of all jobs</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ListJobs</td><td>List the identifiers for all jobs</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.PauseJob</td><td>Given a job identifier, pause the specified job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RestartJob</td><td>Given a job identifier, restart the specified job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunDocumentStatus</td><td>Run a document status report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunMaxActivityHistory</td><td>Run a maximum activity report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunMaxBandwidthHistory</td><td>Run a maximum bandwidth report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunQueueStatus</td><td>Run a queue status report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunResultHistory</td><td>Run a result history report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunSimpleHistory</td><td>Run a simply history report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.StartJob</td><td>Start a job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.WaitForJobDeleted</td><td>After a job has been deleted, wait until the delete has completed</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.WaitForJobInactive</td><td>After a job has been started or aborted, wait until the job ceases all activity</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.WaitJobPaused</td><td>After a job has been paused, wait for the pause to take effect</td></tr>
        </table>
        <p></p>
      </section>
      <section>
        <title>Control by direct code</title>
        <p></p>
        <p>Control by direct java code is quite a reasonable thing to do.  The sources of the above commands should give a pretty clear idea how to proceed, if that's what you
          want to do.</p>
        <p></p>
        <p></p>
      </section>
      <section>
        <title>Caveats</title>
        <p></p>
        <p>The above commands know nothing about the differences between connection types.  Instead, they deal with configuration and specification information in the
          form of XML documents.  Normally, these XML documents are hidden from a system integrator, unless they happen to look into the database with a tool such as
          psql.  But the API commands above often will require such XML documents to be included as part of the command execution.</p>
        <p></p>
        <p>This has one major consequence.  Any application that would manipulate connections and jobs directly cannot be connection-type independent - these
          applications must know the proper form of XML to submit to the command.  So, it is not possible to use these command APIs to write one's own UI wrapper,
          without sacrificing some of the repository independence that ManifoldCF by itself maintains.</p>
      </section>
    </section>
  </body>

</document>
