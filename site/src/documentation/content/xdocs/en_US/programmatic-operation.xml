<?xml version="1.0"?>

<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" 
          "http://forrest.apache.org/dtd/document-v20.dtd">

<!--
 Licensed to the Apache Software Foundation (ASF) under one or more
 contributor license agreements.  See the NOTICE file distributed with
 this work for additional information regarding copyright ownership.
 The ASF licenses this file to You under the Apache License, Version 2.0
 (the "License"); you may not use this file except in compliance with
 the License.  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<document> 

  <header> 
    <title>Programmatic Operation</title> 
  </header> 

  <body> 
    <section>
      <title>Programmatic Operation</title>
      <p></p>
      <p>A certain subset of ManifoldCF users want to think of ManifoldCF as an engine that they can poke from whatever other system they are developing.  While
        ManifoldCF is not precisely a document indexing engine per se, it can certainly be controlled programmatically.  Right now, there are three principle ways of
        achieving this control.</p>
      <p></p>
      <section>
        <title>Control by Servlet API</title>
        <p></p>
        <p>ManifoldCF provides a servlet-based JSON API that gives you the complete ability to define connections and jobs, and control job execution.  You can read
          about JSON <a href="http://www.json.org">here</a>.  The API is designed to be RESTful in character.  Thus, it makes full use of the HTTP verbs
          GET, PUT, POST, and DELETE, and represents objects as URLs.</p>
        <section>
          <title>URL format</title>
          <p></p>
          <p>The basic format of the JSON servlet resource URLs is as follows:</p>
          <p></p>
          <p>http[s]://<em>&lt;server_and_port&gt;</em>/mcf-api-service/json/<em>&lt;resource&gt;</em></p>
          <p></p>
          <p>The servlet ignores request data, except when the PUT or POST verb is used.  In that case, the request data is presumed to be a JSON object.  The servlet
            responds either with an error response code (either 400 or 500) with an appropriate explanatory message, or with a 200 (OK), 201 (CREATED), or
            404 (NOT FOUND) response code along with a response JSON object.</p>
          <p></p>
        </section>
        <section>
          <title>JSON equivalents for ManifoldCF</title>
          <p></p>
          <p>ManifoldCF treats certain JSON forms as equivalent, for the purposes of readability.  For example, the array form <strong>"foo" : [ { ... } ]</strong> is
            treated equivalently to <strong>"foo" : { }</strong>, whenever there is only one array element.  This gives a coder some flexibility as to how s/he encodes
            JSON in requests.  Please also be aware that similar compressions will occur in the JSON responses from the API servlet, and your code must be able to deal
            with this possibility.  The following table describes some of the equivalences:</p>
          <p></p>
          <p></p>
          <p></p>
          <table>
            <tr><th>Form</th><th>Equivalent</th></tr>
            <tr><td>[ { ... } ]</td><td>{ ... }</td></tr>
            <tr><td>"foo" : { "_value_" : "bar" }</td><td>"foo" : "bar"</td></tr>
            <tr><td>"_children_" : [ "foo":{ ... }, "foo":{ ... } ]</td><td>"foo" : [ { ... }, { ... } ]</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Resources and commands</title>
          <p></p>
          <p>The actual available resources and commands are as follows:</p>
          <p></p>
          <p></p>
          <p></p>
          <table>
            <tr><th>Resource</th><th>Verb</th><th>What it does</th><th>Input format/query args</th><th>Output format</th></tr>
            <tr><td>outputconnectors</td><td>GET</td><td>List all registered output connectors</td><td>N/A</td><td>{"outputconnector":[<em>&lt;list_of_output_connector_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnectors</td><td>GET</td><td>List all registered authority connectors</td><td>N/A</td><td>{"authorityconnector":[<em>&lt;list_of_authority_connector_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnectors</td><td>GET</td><td>List all registered repository connectors</td><td>N/A</td><td>{"repositoryconnector":[<em>&lt;list_of_repository_connector_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>outputconnections</td><td>GET</td><td>List all output connections</td><td>N/A</td><td>{"outputconnection":[<em>&lt;list_of_output_connection_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>outputconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a specific output connection</td><td>N/A</td><td>{"outputconnection":<em>&lt;output_connection_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>outputconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Save or create an output connection</td><td>{"outputconnection":<em>&lt;output_connection_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>outputconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>DELETE</td><td>Delete an output connection</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>status/outputconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Check the status of an output connection</td><td>N/A</td><td>{"check_result":<em>&lt;message&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>info/outputconnections/<em>&lt;encoded_connection_name&gt;</em>/<em>&lt;connector_specific_resource&gt;</em></td><td>GET</td><td>Retrieve arbitrary connector-specific resource</td><td>N/A</td><td><em>&lt;response_data&gt;</em> <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} <strong>OR</strong> {"service_interruption":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>reset/outputconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Forget previous indexing state</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnections</td><td>GET</td><td>List all authority connections</td><td>N/A</td><td>{"authorityconnection":[<em>&lt;list_of_authority_connection_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a specific authority connection</td><td>N/A</td><td>{"authorityconnection":<em>&lt;authority_connection_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Save or create an authority connection</td><td>{"authorityconnection":<em>&lt;authority_connection_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>authorityconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>DELETE</td><td>Delete an authority connection</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>status/authorityconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Check the status of an authority connection</td><td>N/A</td><td>{"check_result":<em>&lt;message&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnections</td><td>GET</td><td>List all repository connections</td><td>N/A</td><td>{"repositoryconnection":[<em>&lt;list_of_repository_connection_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a specific repository connection</td><td>N/A</td><td>{"repositoryconnection":<em>&lt;repository_connection_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>PUT</td><td>Save or create a repository connection</td><td>{"repositoryconnection":<em>&lt;repository_connection_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>DELETE</td><td>Delete a repository connection</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>status/repositoryconnections/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Check the status of a repository connection</td><td>N/A</td><td>{"check_result":<em>&lt;message&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>info/repositoryconnections/<em>&lt;encoded_connection_name&gt;</em>/<em>&lt;connector_specific_resource&gt;</em></td><td>GET</td><td>Retrieve arbitrary connector-specific resource</td><td>N/A</td><td><em>&lt;response_data&gt;</em> <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} <strong>OR</strong> {"service_interruption":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs</td><td>GET</td><td>List all job definitions</td><td>N/A</td><td>{"job":[<em>&lt;list_of_job_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs</td><td>POST</td><td>Create a job</td><td>{"job":<em>&lt;job_object&gt;</em>}</td><td>{"job_id":<em>&lt;job_identifier&gt;</em>} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs/<em>&lt;job_id&gt;</em></td><td>GET</td><td>Get a specific job definition</td><td>N/A</td><td>{"job":<em>&lt;job_object_&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Save a job definition</td><td>{"job":<em>&lt;job_object&gt;</em>}</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobs/<em>&lt;job_id&gt;</em></td><td>DELETE</td><td>Delete a job definition</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobstatuses</td><td>GET</td><td>List all jobs and their status</td><td>N/A</td><td>{"jobstatus":[<em>&lt;list_of_job_status_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>jobstatuses/<em>&lt;job_id&gt;</em></td><td>GET</td><td>Get a specific job's status</td><td>N/A</td><td>{"jobstatus":<em>&lt;job_status_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} </td></tr>
            <tr><td>jobstatusesnocounts/<em>&lt;job_id&gt;</em></td><td>GET</td><td>Get a specific job's status, returning '0' for all counts</td><td>N/A</td><td>{"jobstatus":<em>&lt;job_status_object&gt;</em>} <strong>OR</strong> { } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>} </td></tr>
            <tr><td>start/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Start a specified job manually</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>startminimal/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Start a specified job manually, minimal run requested</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>abort/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Abort a specified job</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>restart/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Stop and start a specified job</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>restartminimal/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Stop and start a specified job, minimal run requested</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>pause/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Pause a specified job</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>resume/<em>&lt;job_id&gt;</em></td><td>PUT</td><td>Resume a specified job</td><td>N/A</td><td>{ } <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>

            <tr><td>repositoryconnectionhistory/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a history report</td><td><em>&lt;history_query_parameters&gt;</em></td><td>{"row":[{"column":[{"name":<em>&lt;col_name&gt;</em>,"value":<em>&lt;col_value&gt;</em>}, ...]}, ...]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnectionquery/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a queue report</td><td><em>&lt;queue_query_parameters&gt;</em></td><td>{"row":[{"column":[{"name":<em>&lt;col_name&gt;</em>,"value":<em>&lt;col_value&gt;</em>}, ...]}, ...]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnectionactivities/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a list of legal activities for a connection</td><td>N/A</td><td>{"activity":[<em>&lt;activity_name&gt;</em>, ...]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>
            <tr><td>repositoryconnectionjobs/<em>&lt;encoded_connection_name&gt;</em></td><td>GET</td><td>Get a list of jobs for a connection</td><td>N/A</td><td>{"job":[<em>&lt;list_of_job_objects&gt;</em>]} <strong>OR</strong> {"error":<em>&lt;error_text&gt;</em>}</td></tr>

          </table>
          <p></p>
        </section>
        <section>
          <title>History query parameters</title>
          <p></p>
          <p>The history query parameters and their meanings are as follows:</p>
          <table>
            <tr><th>Parameter</th><th>Report type</th><th>Multivalued?</th><th>Meaning</th></tr>
            <tr><td>report</td><td>All</td><td>No</td><td>The kind of history report desired; legal values are "simple", "maxactivity", "maxbandwidth", and "result"; defaults to "simple"</td></tr>
            <tr><td>starttime</td><td>All</td><td>No</td><td>Starting time in ms since epoch; defaults to "0"</td></tr>
            <tr><td>endtime</td><td>All</td><td>No</td><td>Ending time in ms since epoch; defaults to now</td></tr>
            <tr><td>activity</td><td>All</td><td>Yes</td><td>Which activities you want to see</td></tr>
            <tr><td>entitymatch</td><td>All</td><td>No</td><td>Regular expression matching entity identifier; defaults to ""</td></tr>
            <tr><td>entitymatch_insensitive</td><td>All</td><td>No</td><td>Case insensitive version of entitymatch</td></tr>
            <tr><td>resultcodematch</td><td>All</td><td>No</td><td>Regular expression match result code; defaults to ""</td></tr>
            <tr><td>resultcodematch_insensitive</td><td>All</td><td>No</td><td>Case insensitive version of resultcodematch</td></tr>
            <tr><td>sortcolumn</td><td>All</td><td>Yes</td><td>Result column to sort the result by</td></tr>
            <tr><td>sortcolumn_direction</td><td>All</td><td>Yes</td><td>Direction to sort the corresponding column ("ascending" or "descending")</td></tr>
            <tr><td>startrow</td><td>All</td><td>No</td><td>Starting row in resultset to return; defaults to 0</td></tr>
            <tr><td>rowcount</td><td>All</td><td>No</td><td>Maximum number of rows to return; defaults to 20</td></tr>
            <tr><td>idbucket</td><td>maxactivity, maxbandwidth, result</td><td>No</td><td>Regular expression selecting which part of the entity identifier to use as an aggregation key; defaults to "()"</td></tr>
            <tr><td>idbucket_insensitive</td><td>maxactivity, maxbandwidth, result</td><td>No</td><td>Case insensitive version of idbucket</td></tr>
            <tr><td>resultcodebucket</td><td>result</td><td>No</td><td>Regular expression selecting which part of the result code to use as an aggregation key; defaults to "(.*)"</td></tr>
            <tr><td>resultcodebucket_insensitive</td><td>result</td><td>No</td><td>Case insensitive version of resultcodebucket</td></tr>
            <tr><td>interval</td><td>maxactivity, maxbandwidth</td><td>No</td><td>Size of window in milliseconds for assessing rate; defaults to 300000</td></tr>
          </table>
          <p></p>
          <p>Each report type has different return columns, as listed below:</p>
          <p></p>
          <table>
            <tr><th>Report type</th><th>Return columns</th></tr>
            <tr><td>simple</td><td>starttime, resultcode, resultdesc, identifier, activity, bytes, elapsedtime</td></tr>
            <tr><td>maxactivity</td><td>starttime, endtime, activitycount, idbucket</td></tr>
            <tr><td>maxbandwidth</td><td>starttime, endtime, bytecount, idbucket</td></tr>
            <tr><td>result</td><td>idbucket, resultcodebucket, eventcount</td></tr>
          </table>
        </section>
        <section>
          <title>Queue query parameters</title>
          <p></p>
          <p>The queue query parameters and their meanings are as follows:</p>
          <table>
            <tr><th>Parameter</th><th>Report type</th><th>Multivalued?</th><th>Meaning</th></tr>
            <tr><td>report</td><td>All</td><td>No</td><td>The kind of queue report desired; legal values are "document" or "status"; defaults to "document"</td></tr>
            <tr><td>now</td><td>All</td><td>No</td><td>The time in milliseconds since epoch to perform the queue assessment relative to; defaults to current time</td></tr>
            <tr><td>idmatch</td><td>All</td><td>No</td><td>Regular expression matching document identifier; defaults to ""</td></tr>
            <tr><td>idmatch_insensitive</td><td>All</td><td>No</td><td>Case insensitive version of idmatch</td></tr>
            <tr><td>statematch</td><td>All</td><td>Yes</td><td>State to match; valid values are "neverprocessed", "previouslyprocessed", "outofscope"</td></tr>
            <tr><td>statusmatch</td><td>All</td><td>Yes</td><td>Status to match; valid values are "inactive", "processing", "expiring", "deleting", "readyforprocessing", "readyforexpiration", "waitingforprocessing", "waitingforexpiration", "waitingforever", and "hopcountexceeded"</td></tr>
            <tr><td>sortcolumn</td><td>All</td><td>Yes</td><td>Result column to sort the result by</td></tr>
            <tr><td>sortcolumn_direction</td><td>All</td><td>Yes</td><td>Direction to sort the corresponding column ("ascending" or "descending")</td></tr>
            <tr><td>startrow</td><td>All</td><td>No</td><td>Starting row in resultset to return; defaults to 0</td></tr>
            <tr><td>rowcount</td><td>All</td><td>No</td><td>Maximum number of rows to return; defaults to 20</td></tr>
            <tr><td>idbucket</td><td>status</td><td>No</td><td>Regular expression selecting which part of the document identifier to use as an aggregation key; defaults to "()"</td></tr>
            <tr><td>idbucket_insensitive</td><td>status</td><td>No</td><td>Case insensitive version of idbucket</td></tr>
          </table>
          <p></p>
          <p>Each report type has different return columns, as listed below:</p>
          <p></p>
          <table>
            <tr><th>Report type</th><th>Return columns</th></tr>
            <tr><td>document</td><td>identifier, job, state, status, scheduled, action, retrycount, retrylimit</td></tr>
            <tr><td>status</td><td>idbucket, inactive, processing, expiring, deleting, processready, expireready, processwaiting, expirewaiting, waitingforever, hopcountexceeded</td></tr>
          </table>
        </section>
        <section>
          <title>Output connector objects</title>
          <p></p>
          <p>The JSON fields an output connector object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the connector</td></tr>
            <tr><td>"class_name"</td><td>The class name of the class implementing the connector</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Authority connector objects</title>
          <p></p>
          <p>The JSON fields an authority connector object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the connector</td></tr>
            <tr><td>"class_name"</td><td>The class name of the class implementing the connector</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Repository connector objects</title>
          <p></p>
          <p>The JSON fields a repository connector object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"description"</td><td>The optional description of the connector</td></tr>
            <tr><td>"class_name"</td><td>The class name of the class implementing the connector</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Output connection objects</title>
          <p></p>
          <p>Output connection names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields an output connection object has are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the connection</td></tr>
            <tr><td>"description"</td><td>The description of the connection</td></tr>
            <tr><td>"class_name"</td><td>The java class name of the class implementing the connection</td></tr>
            <tr><td>"max_connections"</td><td>The total number of outstanding connections allowed to exist at a time</td></tr>
            <tr><td>"configuration"</td><td>The configuration object for the connection, which is specific to the connection class</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Authority connection objects</title>
          <p></p>
          <p>Authority connection names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields for an authority connection object are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the connection</td></tr>
            <tr><td>"description"</td><td>The description of the connection</td></tr>
            <tr><td>"class_name"</td><td>The java class name of the class implementing the connection</td></tr>
            <tr><td>"max_connections"</td><td>The total number of outstanding connections allowed to exist at a time</td></tr>
            <tr><td>"configuration"</td><td>The configuration object for the connection, which is specific to the connection class</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Repository connection objects</title>
          <p></p>
          <p>Repository connection names, when they are part of a URL, should be encoded as follows:</p>
          <p></p>
          <ol>
            <li>All instances of '.' should be replaced by '..'.</li>
            <li>All instances of '/' should be replaced by '.+'.</li>
            <li>The URL should be encoded using standard URL utf-8-based %-encoding.</li>
          </ol>
          <p></p>
          <p>The JSON fields for a repository connection object are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"name"</td><td>The unique name of the connection</td></tr>
            <tr><td>"description"</td><td>The description of the connection</td></tr>
            <tr><td>"class_name"</td><td>The java class name of the class implementing the connection</td></tr>
            <tr><td>"max_connections"</td><td>The total number of outstanding connections allowed to exist at a time</td></tr>
            <tr><td>"configuration"</td><td>The configuration object for the connection, which is specific to the connection class</td></tr>
            <tr><td>"acl_authority"</td><td>The (optional) name of the authority that will enforce security for this connection</td></tr>
            <tr><td>"throttle"</td><td>An array of throttle objects, which control how quickly documents can be requested from this connection</td></tr>
          </table>
          <p></p>
          <p>Each throttle object has the following fields:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"match"</td><td>The regular expression which is used to match a document's bins to determine if the throttle should be applied</td></tr>
            <tr><td>"match_description"</td><td>Optional text describing the meaning of the throttle</td></tr>
            <tr><td>"rate"</td><td>The maximum fetch rate to use if the throttle applies, in fetches per minute</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Job objects</title>
          <p></p>
          <p>The JSON fields for a job are is as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"id"</td><td>The job's identifier, if present.  If not present, ManifoldCF will create one (and will also create the job when saved).</td></tr>
            <tr><td>"description"</td><td>Text describing the job</td></tr>
            <tr><td>"repository_connection"</td><td>The name of the repository connection to use with the job</td></tr>
            <tr><td>"output_connection"</td><td>The name of the output connection to use with the job</td></tr>
            <tr><td>"document_specification"</td><td>The document specification object for the job, whose format is repository-connection specific</td></tr>
            <tr><td>"output_specification"</td><td>The output specification object for the job, whose format is output-connection specific</td></tr>
            <tr><td>"start_mode"</td><td>The start mode for the job, which can be one of "schedule window start", "schedule window anytime", or "manual"</td></tr>
            <tr><td>"run_mode"</td><td>The run mode for the job, which can be either "continuous" or "scan once"</td></tr>
            <tr><td>"hopcount_mode"</td><td>The hopcount mode for the job, which can be either "accurate", "no delete", "never delete"</td></tr>
            <tr><td>"priority"</td><td>The job's priority, typically "5"</td></tr>
            <tr><td>"recrawl_interval"</td><td>The default time between recrawl of documents (if the job is "continuous"), in milliseconds, or "infinite" for infinity</td></tr>
            <tr><td>"expiration_interval"</td><td>The time until a document expires (if the job is "continuous"), in milliseconds, or "infinite" for infinity</td></tr>
            <tr><td>"reseed_interval"</td><td>The time between reseeding operations (if the job is "continuous"), in milliseconds, or "infinite" for infinity</td></tr>
            <tr><td>"hopcount"</td><td>An array of hopcount objects, describing the link types and associated maximum hops permitted for the job</td></tr>
            <tr><td>"schedule"</td><td>An array of schedule objects, describing when the job should be started and run</td></tr>
          </table>
          <p></p>
          <p>Each hopcount object has the following fields:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"link_type"</td><td>The connection-type-dependent type of a link for which a hop count restriction is specified</td></tr>
            <tr><td>"count"</td><td>The maximum number of hops allowed for the associated link type, starting at a seed</td></tr>
          </table>
          <p></p>
          <p>Each schedule object has the following fields:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"timezone"</td><td>The optional time zone for the schedule object; if not present the default server time zone is used</td></tr>
            <tr><td>"duration"</td><td>The optional length of the described time window, in milliseconds; if not present, duration is considered infinite</td></tr>
            <tr><td>"dayofweek"</td><td>The optional day-of-the-week enumeration object</td></tr>
            <tr><td>"monthofyear"</td><td>The optional month-of-the-year enumeration object</td></tr>
            <tr><td>"dayofmonth"</td><td>The optional day-of-the-month enumeration object</td></tr>
            <tr><td>"year"</td><td>The optional year enumeration object</td></tr>
            <tr><td>"hourofday"</td><td>The optional hour-of-the-day enumeration object</td></tr>
            <tr><td>"minutesofhour"</td><td>The optional minutes-of-the-hour enumeration object</td></tr>
            <tr><td>"requestminimum"</td><td>Optional flag indicating whether the job run will be minimal or not ("true" means minimal)</td></tr>
          </table>
          <p></p>
          <p>Each enumeration object describes an array of integers using the form:</p>
          <p></p>
          <p>{"value":[<em>&lt;integer_list&gt;</em>]}</p>
          <p></p>
          <p>Each integer is a zero-based index describing which entity is being specified.  For example, for "dayofweek", 0 corresponds to Sunday, etc., and thus "dayofweek":{"value":[0,6]} would describe Saturdays and Sundays.</p>
          <p></p>
        </section>
        <section>
          <title>Job status objects</title>
          <p></p>
          <p>The JSON fields of a job status object are as follows:</p>
          <p></p>
          <table>
            <tr><th>Field</th><th>Meaning</th></tr>
            <tr><td>"job_id"</td><td>The job identifier</td></tr>
            <tr><td>"status"</td><td>The job status, having the possible values: "not yet run", "running", "paused", "done", "waiting", "stopping", "resuming", "starting up", "cleaning up", "error", "aborting", "restarting", "running no connector", and "terminating"</td></tr>
            <tr><td>"error_text"</td><td>The error text, if the status is "error"</td></tr>
            <tr><td>"start_time"</td><td>The job start time, in milliseconds since Jan 1, 1970</td></tr>
            <tr><td>"end_time"</td><td>The job end time, in milliseconds since Jan 1, 1970</td></tr>
            <tr><td>"documents_in_queue"</td><td>The total number of documents in the queue for the job</td></tr>
            <tr><td>"documents_outstanding"</td><td>The number of documents for the job that are currently considered 'active'</td></tr>
            <tr><td>"documents_processed"</td><td>The number of documents that in the queue for the job that have been processed at least once</td></tr>
          </table>
          <p></p>
        </section>
        <section>
          <title>Connection-type-specific objects</title>
          <p></p>
          <p>As you may note when trying to use the above JSON API methods, you cannot get very far in defining connections or jobs without knowing the JSON format of a connection's configuration information, or a job's connection-specific document specification and output specification information.  The form of these objects is controlled by the Java implementation of the underlying connector, and is translated directly into JSON, so if you write your own connector you should be able to figure out what it will be in the API.  For connectors already part of ManifoldCF, it remains an ongoing task to document these connector-specific objects.  This task is not yet underway.</p>
          <p></p>
          <p>Luckily, it is pretty easy to learn a lot about the objects in question by simply creating connections and jobs in the ManifoldCF crawler UI, and then inspecting the resulting JSON objects through the API.  In this way, it should be possible to do a decent job of coding most API-based integrations.  The one place where difficulties will certainly occur will be if you try to completely replace the ManifoldCF crawler UI with one of your own.  This is because most connectors have methods that communicate with their respective back-ends in order to allow the user to select appropriate values.  For example, the path drill-down that is presented by the LiveLink connector requires that the connector interrogate the appropriate LiveLink repository in order to populate its path selection pull-downs.  There is, at this time, only one sanctioned way to accomplish the same job using the API, which is to use the appropriate "<em>connection_type</em>/execute/<em>type-specific_command</em>" command to perform the necessary functions.  Some set of useful functions has been coded for every appropriate connector, but the exact commands for every connector, and their JSON syntax, remains undocumented for now.</p>
          <p></p>
        </section>
        <section>
          <title>File system connector</title>
          <p></p>
          <p>The file system connector has no configuration information, and no connector-specific commands.  However, it does have document specification information.  The information looks something like this:</p>
          <p></p>
          <p>{"startpoint":[{"_attribute_path":"c:\path_to_files","include":[{"_attribute_type":"file","_attribute_match":"*.txt"},{"_attribute_type":"file","_attribute_match":"*.doc"\,"_attribute_type":"directory","_attribute_match":"*"],"exclude":["*.mov"]]}</p>
          <p></p>
          <p>As you can see, multiple starting paths are possible, and the inclusion and exclusion rules also can be one or multiple.</p>
          <p></p>
          <p></p>
        </section>
      </section>
      <section>
        <title>Control via Commands</title>
        <p></p>
        <p>For script writers, there currently exist a number of ManifoldCF execution commands.  These commands are primarily rich in the area of definition of connections and jobs, controlling jobs, and running reports.  The following table lists the current suite.</p>
        <p></p>
        <table>
          <tr><th>Command</th><th>What it does</th></tr>
          <tr><td>org.apache.manifoldcf.agents.DefineOutputConnection</td><td>Create a new output connection</td></tr>
          <tr><td>org.apache.manifoldcf.agents.DeleteOutputConnection</td><td>Delete an existing output connection</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.ChangeAuthSpec</td><td>Modify an authority's configuration information</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.CheckAll</td><td>Check all authorities to be sure they are functioning</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.DefineAuthorityConnection</td><td>Create a new authority connection</td></tr>
          <tr><td>org.apache.manifoldcf.authorities.DeleteAuthorityConnection</td><td>Delete an existing authority connection</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.AbortJob</td><td>Abort a running job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.AddScheduledTime</td><td>Add a schedule record to a job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ChangeJobDocSpec</td><td>Modify a job's specification information</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.DefineJob</td><td>Create a new job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.DefineRepositoryConnection</td><td>Create a new repository connection</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.DeleteJob</td><td>Delete an existing job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.DeleteRepositoryConnection</td><td>Delete an existing repository connection</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ExportConfiguration</td><td>Write the complete list of all connection definitions and job specifications to a file</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.FindJob</td><td>Locate a job identifier given a job's name</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.GetJobSchedule</td><td>Find a job's schedule given a job's identifier</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ImportConfiguration</td><td>Import configuration as written by a previous ExportConfiguration command</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ListJobStatuses</td><td>List the status of all jobs</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.ListJobs</td><td>List the identifiers for all jobs</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.PauseJob</td><td>Given a job identifier, pause the specified job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RestartJob</td><td>Given a job identifier, restart the specified job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunDocumentStatus</td><td>Run a document status report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunMaxActivityHistory</td><td>Run a maximum activity report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunMaxBandwidthHistory</td><td>Run a maximum bandwidth report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunQueueStatus</td><td>Run a queue status report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunResultHistory</td><td>Run a result history report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.RunSimpleHistory</td><td>Run a simply history report</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.StartJob</td><td>Start a job</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.WaitForJobDeleted</td><td>After a job has been deleted, wait until the delete has completed</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.WaitForJobInactive</td><td>After a job has been started or aborted, wait until the job ceases all activity</td></tr>
          <tr><td>org.apache.manifoldcf.crawler.WaitJobPaused</td><td>After a job has been paused, wait for the pause to take effect</td></tr>
        </table>
        <p></p>
      </section>
      <section>
        <title>Control by direct code</title>
        <p></p>
        <p>Control by direct java code is quite a reasonable thing to do.  The sources of the above commands should give a pretty clear idea how to proceed, if that's what you
          want to do.</p>
        <p></p>
        <p></p>
      </section>
      <section>
        <title>Caveats</title>
        <p></p>
        <p>The above commands know nothing about the differences between connection types.  Instead, they deal with configuration and specification information in the
          form of XML documents.  Normally, these XML documents are hidden from a system integrator, unless they happen to look into the database with a tool such as
          psql.  But the API commands above often will require such XML documents to be included as part of the command execution.</p>
        <p></p>
        <p>This has one major consequence.  Any application that would manipulate connections and jobs directly cannot be connection-type independent - these
          applications must know the proper form of XML to submit to the command.  So, it is not possible to use these command APIs to write one's own UI wrapper,
          without sacrificing some of the repository independence that ManifoldCF by itself maintains.</p>
      </section>
    </section>
  </body>

</document>
